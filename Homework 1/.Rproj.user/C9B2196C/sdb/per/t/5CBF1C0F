{
    "collab_server" : "",
    "contents" : "# file MASS/R/fitdistr.R\n# copyright (C) 2002-2010 W. N. Venables and B. D. Ripley\n#\n#  This program is free software; you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation; either version 2 or 3 of the License\n#  (at your option).\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  A copy of the GNU General Public License is available at\n#  http://www.r-project.org/Licenses/\n#\n\nfitdistr <- function(x, densfun, start, ...)\n{\n    myfn <- function(parm, ...) -sum(log(dens(parm, ...)))\n    mylogfn <- function(parm, ...) -sum(dens(parm, ..., log = TRUE))\n    mydt <- function(x, m, s, df, log) dt((x-m)/s, df, log = TRUE) - log(s)\n\n    Call <- match.call(expand.dots=TRUE)\n    if(missing(start)) start <- NULL\n    dots <- names(list(...))\n    dots <- dots[!is.element(dots, c(\"upper\", \"lower\"))]\n    if(missing(x) || length(x) == 0L || mode(x) != \"numeric\")\n        stop(\"'x' must be a non-empty numeric vector\")\n    if(any(!is.finite(x))) stop(\"'x' contains missing or infinite values\")\n    if(missing(densfun) || !(is.function(densfun) || is.character(densfun)))\n        stop(\"'densfun' must be supplied as a function or name\")\n    n <- length(x)\n    if(is.character(densfun)) {\n        distname <- tolower(densfun)\n        densfun <-\n            switch(distname,\n                   \"beta\" = dbeta,\n                   \"cauchy\" = dcauchy,\n                   \"chi-squared\" = dchisq,\n                   \"exponential\" = dexp,\n                   \"f\" = df,\n                   \"gamma\" = dgamma,\n                   \"geometric\" = dgeom,\n                   \"log-normal\" = dlnorm,\n                   \"lognormal\" = dlnorm,\n                   \"logistic\" = dlogis,\n                   \"negative binomial\" = dnbinom,\n                   \"normal\" = dnorm,\n                   \"poisson\" = dpois,\n                   \"t\" = mydt,\n                   \"weibull\" = dweibull,\n                   NULL)\n        if(is.null(densfun)) stop(\"unsupported distribution\")\n        if(distname %in% c(\"lognormal\",  \"log-normal\")) {\n            if(!is.null(start))\n                stop(\"supplying pars for the log-Normal is not supported\")\n            if(any(x <= 0))\n                stop(\"need positive values to fit a log-Normal\")\n            lx <- log(x)\n            sd0 <- sqrt((n-1)/n)*sd(lx)\n            mx <- mean(lx)\n            estimate <- c(mx, sd0)\n            sds <- c(sd0/sqrt(n), sd0/sqrt(2*n))\n            names(estimate) <- names(sds) <- c(\"meanlog\", \"sdlog\")\n            vc <- matrix(c(sds[1]^2, 0, 0, sds[2]^2), ncol = 2,\n                         dimnames = list(names(sds), names(sds)))\n            names(estimate) <- names(sds) <- c(\"meanlog\", \"sdlog\")\n            return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n,\n\t\t\t\t  loglik = sum(dlnorm(x, mx, sd0, log=TRUE))),\n                             class = \"fitdistr\"))\n        }\n        if(distname == \"normal\") {\n            if(!is.null(start))\n                stop(\"supplying pars for the Normal is not supported\")\n            sd0 <- sqrt((n-1)/n)*sd(x)\n            mx <- mean(x)\n            estimate <- c(mx, sd0)\n            sds <- c(sd0/sqrt(n), sd0/sqrt(2*n))\n            names(estimate) <- names(sds) <- c(\"mean\", \"sd\")\n            vc <- matrix(c(sds[1]^2, 0, 0, sds[2]^2), ncol = 2,\n                         dimnames = list(names(sds), names(sds)))\n            return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n,\n\t\t\t\t  loglik = sum(dnorm(x, mx, sd0, log=TRUE))),\n                             class = \"fitdistr\"))\n        }\n        if(distname == \"poisson\") {\n            if(!is.null(start))\n                stop(\"supplying pars for the Poisson is not supported\")\n            estimate <- mean(x)\n            sds <- sqrt(estimate/n)\n            names(estimate) <- names(sds) <- \"lambda\"\n\t    vc <- matrix(sds^2, ncol = 1, nrow = 1,\n                         dimnames = list(\"lambda\", \"lambda\"))\n            return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n,\n\t\t\t\t  loglik = sum(dpois(x, estimate, log=TRUE))),\n                             class = \"fitdistr\"))\n        }\n        if(distname == \"exponential\") {\n            if(any(x < 0)) stop(\"Exponential values must be >= 0\")\n            if(!is.null(start))\n                stop(\"supplying pars for the exponential is not supported\")\n            estimate <- 1/mean(x)\n            sds <- estimate/sqrt(n)\n\t    vc <- matrix(sds^2, ncol = 1, nrow = 1,\n                         dimnames = list(\"rate\", \"rate\"))\n            names(estimate) <- names(sds) <- \"rate\"\n            return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n,\n\t\t\t\t  loglik = sum(dexp(x, estimate, log=TRUE))),\n                             class = \"fitdistr\"))\n        }\n        if(distname == \"geometric\") {\n            if(!is.null(start))\n                stop(\"supplying pars for the geometric is not supported\")\n            estimate <- 1/(1 + mean(x))\n            sds <- estimate * sqrt((1-estimate)/n)\n\t    vc <- matrix(sds^2, ncol = 1, nrow = 1,\n                         dimnames = list(\"prob\", \"prob\"))\n            names(estimate) <- names(sds) <- \"prob\"\n            return(structure(list(estimate = estimate, sd = sds, vcov = vc, n = n,\n\t\t\t\t  loglik = sum(dexp(x, estimate, log=TRUE))),\n                             class = \"fitdistr\"))\n        }\n        if(distname == \"weibull\" && is.null(start)) {\n            ## log-Weibull is Gumbel, so start from that\n            ## but some people think Weibull range is [0, \\infty)\n            if(any(x <= 0)) stop(\"Weibull values must be > 0\")\n            lx <- log(x)\n            m <- mean(lx); v <- var(lx)\n            shape <- 1.2/sqrt(v); scale <- exp(m + 0.572/shape)\n            start <- list(shape = shape, scale = scale)\n            start <- start[!is.element(names(start), dots)]\n        }\n        if(distname == \"gamma\" && is.null(start)) {\n            if(any(x < 0)) stop(\"gamma values must be >= 0\")\n            m <- mean(x); v <- var(x)\n            start <- list(shape = m^2/v, rate = m/v)\n            start <- start[!is.element(names(start), dots)]\n        }\n        if(distname == \"negative binomial\" && is.null(start)) {\n            m <- mean(x); v <- var(x)\n            size <- if(v > m) m^2/(v - m) else 100\n            start <- list(size = size, mu = m)\n            start <- start[!is.element(names(start), dots)]\n        }\n        if(is.element(distname, c(\"cauchy\", \"logistic\")) && is.null(start)) {\n            start <- list(location = median(x), scale = IQR(x)/2)\n            start <- start[!is.element(names(start), dots)]\n        }\n        if(distname == \"t\" && is.null(start)) {\n            start <- list(m = median(x), s = IQR(x)/2, df = 10)\n            start <- start[!is.element(names(start), dots)]\n        }\n    }\n    if(is.null(start) || !is.list(start))\n        stop(\"'start' must be a named list\")\n    nm <- names(start)\n    ## reorder arguments to densfun\n    f <- formals(densfun)\n    args <- names(f)\n    m <- match(nm, args)\n    if(any(is.na(m)))\n        stop(\"'start' specifies names which are not arguments to 'densfun'\")\n    formals(densfun) <- c(f[c(1, m)], f[-c(1, m)])\n    dens <- function(parm, x, ...) densfun(x, parm, ...)\n    if((l <- length(nm)) > 1L)\n        body(dens) <-\n            parse(text = paste(\"densfun(x,\",\n                  paste(\"parm[\", 1L:l, \"]\", collapse = \", \"),\n                  \", ...)\"))\n    Call[[1L]] <- as.name(\"optim\")\n    Call$densfun <- Call$start <- NULL\n    Call$x <- x # want local variable as eval in this frame\n    Call$par <- start\n    Call$fn <- if(\"log\" %in% args) mylogfn else myfn\n    Call$hessian <- TRUE\n    if(is.null(Call$method)) {\n        if(any(c(\"lower\", \"upper\") %in% names(Call))) Call$method <- \"L-BFGS-B\"\n        else if (length(start) > 1L) Call$method <- \"BFGS\"\n        else Call$method <- \"Nelder-Mead\"\n    }\n    res <- eval.parent(Call)\n    if(res$convergence > 0L) stop(\"optimization failed\")\n    vc <- solve(res$hessian)\n    sds <- sqrt(diag(vc))\n    structure(list(estimate = res$par, sd = sds, vcov = vc,\n                   loglik = - res$value, n = n), class = \"fitdistr\")\n}\n\nvcov.fitdistr <- function(object, ...) object$vcov\n\nlogLik.fitdistr <- function(object, REML = FALSE, ...)\n{\n    if (REML) stop(\"only 'REML = FALSE' is implemented\")\n    val <- object$loglik\n    attr(val, \"nobs\") <- object$n\n    attr(val, \"df\") <- length(object$estimate)\n    class(val) <- \"logLik\"\n    val\n}\n\n\nprint.fitdistr <-\n    function(x, digits = getOption(\"digits\"), ...)\n{\n    ans <- format(rbind(x$estimate, x$sd), digits=digits)\n    ans[1L, ] <- sapply(ans[1L, ], function(x) paste(\"\", x))\n    ans[2L, ] <- sapply(ans[2L, ], function(x) paste(\"(\", x, \")\", sep=\"\"))\n    ## only used for digits\n    dn <- dimnames(ans)\n    dn[[1L]] <- rep(\"\", 2L)\n    dn[[2L]] <- paste(substring(\"      \", 1L, (nchar(ans[2L,]) - nchar(dn[[2L]])) %/% 2), dn[[2L]])\n    dn[[2L]] <- paste(dn[[2L]], substring(\"      \", 1L, (nchar(ans[2L,]) - nchar(dn[[2L]])) %/% 2))\n    dimnames(ans) <- dn\n    print(ans, quote = FALSE)\n    invisible(x)\n}\n\ncoef.fitdistr <- function(object, ...) object$estimate\n\n",
    "created" : 1460338478494.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3570207691",
    "id" : "5CBF1C0F",
    "lastKnownWriteTime" : 1460150930,
    "last_content_update" : 1460150930,
    "path" : "~/Documents/Masters/CS 249/Homework/HW0/fitdistr.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}